import { igniteEngine, Message } from "multi-llm-ts";
import { PROVIDERS } from "@/config/models";
import { candidateRepository } from "@/repositories/CandidateRepository";
import { AssessmentResult, Snippet } from "@/types";
import { ObjectId } from "mongodb";

export class AssessmentService {
  async generateAssessment(params: {
    thingName: string;
    context: string;
    snippets: Snippet[];
    providerId: string;
    modelId: string;
  }): Promise<AssessmentResult> {
    const { thingName, context, snippets, providerId, modelId } = params;

    const provider = PROVIDERS.find((p) => p.id === providerId);
    if (!provider) {
      throw new Error(`Provider ${providerId} not found.`);
    }

    const isConfigured = 
      (provider.apiKey && provider.apiKey !== "YOUR_API_KEY_HERE" && provider.apiKey !== "") ||
      (provider.baseURL && provider.baseURL !== "" && provider.id === "ollama");

    if (!isConfigured) {
      throw new Error(`Provider ${providerId} is not configured.`);
    }

    const engineConfig: any = { 
      timeout: 120000 
    };

    if (provider.apiKey) engineConfig.apiKey = provider.apiKey;
    if (provider.baseURL) engineConfig.baseURL = provider.baseURL;

    // Resolve candidate names for the prompt
    const candidateMap: Record<string, string> = {}; 
    const nameToIdMap: Record<string, string> = {}; 
    
    const dbCandidateIds = Array.from(new Set(
      snippets
        .filter((s) => s.candidateId && ObjectId.isValid(s.candidateId))
        .map((s) => new ObjectId(s.candidateId))
    ));

    // Guard: Ensure no duplicate candidate IDs are passed in snippets
    if (dbCandidateIds.length !== snippets.length) {
      throw new Error("Duplicate candidates are not allowed in a single assessment run.");
    }

    if (dbCandidateIds.length > 0) {
      const candidates = await candidateRepository.findAll({ _id: { $in: dbCandidateIds } } as any);
      candidates.forEach(c => {
        const idStr = c._id.toString();
        candidateMap[idStr] = c.name;
        nameToIdMap[c.name.toLowerCase()] = idStr;
      });
    }

    for (const s of snippets) {
      if (s.candidateId && !candidateMap[s.candidateId.toString()]) {
        const name = `Candidate ${s.candidateId}`;
        candidateMap[s.candidateId.toString()] = name;
        nameToIdMap[name.toLowerCase()] = s.candidateId.toString();
      }
    }

    const engine = igniteEngine(providerId, engineConfig);
    const chatModel = engine.buildModel(modelId);

    let codeBlockSection = "";
    snippets.forEach((s) => {
      const name = candidateMap[s.candidateId.toString()] || "Unknown Candidate";
      codeBlockSection += `\n${name}:\n\`\`\`${(s as any).language || "javascript"}\n${s.content}\n\`\`\`\n`;
    });

    const prompt = `
Conduct a rigorous, professional assessment of these ${thingName} implementations.

Code context: ${context || "Not provided"}.

3. At the very end of your response, provide a ranked list of all candidates from best to worst using the following format:
<SCORES>
1: [Candidate Name]
2: [Candidate Name]
...
n: [Candidate Name]
</SCORES>

Implementations:
${codeBlockSection}
`;

    let text = "";
    const messages = [new Message("user", prompt)];
    const stream = engine.generate(chatModel, messages, {
      maxTokens: 6000,
      temperature: 1.0
    });

    for await (const chunk of stream) {
      if (chunk.type === 'content') {
        text += chunk.text || "";
      }
    }
    
    if (!text) throw new Error("LLM returned no content");

    // Extract ranking scores
    const structuredScores: Record<string, string> = {};
    const scoresRegex = /<SCORES>([\s\S]*?)<\/SCORES>/i;
    const scoresMatch = text.match(scoresRegex);

    if (scoresMatch) {
      const lines = scoresMatch[1].trim().split("\n").filter((l) => l.trim() !== "");
      lines.forEach((line) => {
        const match = line.match(/^\s*(\d+)\s*:\s*(.+)$/);
        if (match) {
          const rank = parseInt(match[1]);
          const candidateName = match[2].trim();
          const id = nameToIdMap[candidateName.toLowerCase()];
          if (id) {
            structuredScores[id] = String(rank);
          } else {
            structuredScores[candidateName] = String(rank);
          }
        }
      });
    }

    const reportMarkdown = `# Architectural Assessment Report for: ${thingName}\n\r\n**Code context:** ${context || "Not provided"} \r\n\r\n` + 
      text + 
      `\n\n---\n\n### Appendix: Assessment Methodology\n\nThis report was generated by an AI architectural assessment engine.\n\n- **Provider:** ${providerId}\n- **Model:** ${modelId}\n\n#### Prompt Configuration:\n\n\`\`\`text\n${prompt.trim()}\n\`\`\``;

    return {
      providerId,
      modelId,
      reportMarkdown,
      scores: structuredScores,
      timestamp: new Date()
    };
  }
}

export const assessmentService = new AssessmentService();
